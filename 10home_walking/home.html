<!DOCTYPE html>
<html>
<head>
    <title>室内漫游 - tyw66</title>
	<link rel="icon" href="../common/icon.ico" type="image/x-icon">
	<meta charset='utf-8' />
    <script type="text/javascript" src="../lib/ThreeJS/three.min.js"></script>	
	<script type="text/javascript" src="../lib/ThreeJS/OBJLoader.js"></script>
	<script type="text/javascript" src="../lib/ThreeJS/MTLLoader.js"></script>	
	<script type="text/javascript" src="../lib/ThreeJS/OrbitControls.js"></script>
	<script type="text/javascript" src="../lib/ThreeJS/FirstPersonControls.js"></script>
	
    <script type="text/javascript" src="../lib/stats.js"></script>
    <script type="text/javascript" src="../lib/dat.gui.min.js"></script>
	    
    <style>
        body {
            margin: 0;
            overflow: hidden;
        }
		#comment{
			text-align: center;
		}
    </style>
</head>

<body>

<div id="Stats-output">
</div>
<div id="comment">
	使用WASD进行移动，滑动鼠标查看四周。
</div>
<div id="WebGL-output">
</div>

<!-- Javascript ThreeJs code -->
<script type="text/javascript">
    window.onload = init;
	
    function init() {
		//建立场景，包括相机、渲染器
		createScene();
		//建立灯光
		createLights();
		//建立模型
		createModel();
		//建立控制器
		createControl();
		//建立其他对象
		createItem();
		//建立事件关联
		createListener();
		//渲染相机里场景
        render();
	
	
		var scene, camera, renderer;		
		function createScene(){
			scene = new THREE.Scene();
			camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 100000);
			camera.position.x = 100;
			camera.position.y = 66;
			camera.position.z = 500;
			camera.lookAt(scene.position);
			//camera.lookAt(0,0,-1);	  
			//camera.updateProjectionMatrix();
			
			renderer = new THREE.WebGLRenderer();
			renderer.setClearColor(0x999999, 1.0);
			renderer.setSize(window.innerWidth, window.innerHeight);

			renderer.shadowMap.enabled = true;
			document.getElementById("WebGL-output").appendChild(renderer.domElement);
		}
		
		var ambientLight, spotLight, light, lightHelper;
		function createLights(){
			ambientLight = new THREE.AmbientLight(0x888888);
			scene.add(ambientLight);		
			
			//var light = new THREE.DirectionalLight( 0xffffff, 0.2, 100 );
			//light.position.set( 0, 500, -500 );
			//light.target.position.set( 0, 0, 0 );
			//light.angle = Math.PI / 4;
			//light.castShadow = true;
			//light.receiveShadow = true;
			//light.shadow.mapSize.width = 10;
			//light.shadow.mapSize.height = 10;
			//light.shadow.camera.near = 10;
			//light.shadow.camera.far = 20;
			//scene.add( light );

			spotLight = new THREE.SpotLight(0xffffff,0.6);
			spotLight.position.set(0, 500, -500);
			spotLight.castShadow = true;
			scene.add(spotLight);
				
			//lightHelper = new THREE.SpotLightHelper( light );
			//scene.add( lightHelper );		
		}
	
		function createModel(){
			var onProgress = function ( xhr ) {
				if ( xhr.lengthComputable ) {
					var percentComplete = xhr.loaded / xhr.total * 100;
					console.log( Math.round( percentComplete, 2 ) + '% downloaded' );
				}
			};

			var onError = function ( xhr ) { };
			new THREE.MTLLoader()
				.setPath( './model/' )
				.load( 'for_test.mtl', function ( materials ) {
					materials.preload();
					new THREE.OBJLoader()
						.setMaterials( materials )
						.setPath( './model/' )
						.load( 'for_test.obj', function ( object ) {
							object.rotateY(180);
							object.traverse(function(o){
								o.receiveShadow = true;
								console.log(o.name);
							});						
							scene.add( object );
						}, onProgress, onError );
				} );			
				
			//TEMP
			var cubeGeometry = new THREE.BoxGeometry(40, 40, 40);
			var cubeMaterial = new THREE.MeshPhongMaterial({color: 0xf58cff, wireframe: false});
			var test = new THREE.Mesh(cubeGeometry, cubeMaterial);
			test.position.x = 0;
			test.position.y = 0;
			test.position.z = 300;
			test.name = "testmodel";
			scene.add( test );		
		
		}

		var clock, firstPersonControl, orbitControl;
		function createControl(){
			//相机控制
			clock = new THREE.Clock();
			firstPersonControl = new THREE.FirstPersonControls(camera);
			firstPersonControl.lookSpeed = 0.05; //鼠标移动查看的速度
			firstPersonControl.movementSpeed = 100; //相机移动速度
			firstPersonControl.lookVertical = true;
			firstPersonControl.noFly = true;
			firstPersonControl.constrainVertical = true; //约束垂直
			
			firstPersonControl.verticalMin = 1.0;
			firstPersonControl.verticalMax = 2.0;
			firstPersonControl.lon = -50; //进入初始视角x轴的角度
			//firstPersonControl.lat = 0; //初始视角进入后y轴的角度		

			//orbitControl = new THREE.OrbitControls(camera,document.getElementById("WebGL-output"));
		}

		var stats, AxesHelper, mouse;
		function createItem(){
			AxesHelper = new THREE.AxesHelper(10000);
			scene.add(AxesHelper);	
			
			stats = initStats();
			mouse = new THREE.Vector2();

		}

		function createListener(){
			document.addEventListener( 'mousemove', onDocumentMouseMove, false );
		
		}



        function render() {
            stats.update();   
			
			firstPersonControl.update(clock.getDelta());
			//摄影机高度维持在人眼的高度
			camera.position.y = 66;
			
			//相交判断
			intersect();
			
            requestAnimationFrame(render);
            renderer.render(scene, camera);
        }

        function initStats() {
            var stats = new Stats();
            stats.setMode(0); // 0: fps, 1: ms
            // Align top-left
            stats.domElement.style.position = 'absolute';
            stats.domElement.style.left = '0px';
            stats.domElement.style.top = '0px';
            document.getElementById("Stats-output").appendChild(stats.domElement);
            return stats;
        }

		function onDocumentMouseMove( event ) {
			event.preventDefault();
			mouse.x = ( event.clientX / window.innerWidth ) * 2 - 1;
			mouse.y = - ( event.clientY / window.innerHeight ) * 2 + 1;

		}
		
		//光线投射
		var INTERSECTED, raycaster ;
		function intersect(){
			raycaster = new THREE.Raycaster();
			raycaster.setFromCamera( mouse, camera );
			var intersects = raycaster.intersectObjects( scene.children , true);			
			if ( intersects.length > 0 ) {
				if ( INTERSECTED != intersects[ 0 ].object ) {
					if ( INTERSECTED ){
						INTERSECTED.material.color.setHex( INTERSECTED.currentHex );
					}
					INTERSECTED = intersects[ 0 ].object;
					INTERSECTED.currentHex = INTERSECTED.material.color.getHex();
					INTERSECTED.material.color.setHex( 0xff0000 );		
					INTERSECTED.material.transparent = true;
				}
			} else {
				if ( INTERSECTED ){
					INTERSECTED.material.color.setHex( INTERSECTED.currentHex );
					INTERSECTED.material.transparent = false;
				} 
				INTERSECTED = null;
			}			
		}
		
		
    }


	
</script>
</body>
</html>