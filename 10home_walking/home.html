<!DOCTYPE html>
<html lang="zh-cn">
<head>
    <title>室内漫游 - tyw66</title>
	<link rel="icon" href="../common/icon.ico" type="image/x-icon">
	<meta charset='utf-8' />
    <script type="text/javascript" src="../lib/ThreeJS/three.min.js"></script>	
	<script type="text/javascript" src="../lib/ThreeJS/OBJLoader.js"></script>
	<script type="text/javascript" src="../lib/ThreeJS/MTLLoader.js"></script>	
	<script type="text/javascript" src="../lib/ThreeJS/OrbitControls.js"></script>
	<script type="text/javascript" src="../lib/ThreeJS/FirstPersonControls.js"></script>
	
    <script type="text/javascript" src="../lib/stats.js"></script>
    <script type="text/javascript" src="../lib/dat.gui.min.js"></script>
	    
    <style>
        body {
            margin: 0;
            overflow: hidden;
        }
		#comment{			
			position:absolute; 
			top:10px; 
			left:10px; 
			z-index:1000;	
			color:#FFF;

			text-align: center;
		}
		#info-area{
			position:absolute; 
			top:40px; 
			left:10px; 
			z-index:1000;
			
			text-align: center;
			color:#FFF;
			font-size:3em;
			
		}

    </style>
</head>

<body>

<div id="Stats-output">
</div>
<div id="comment">
	使用WASD进行移动，滑动鼠标查看四周。
</div>
<div id="info-area">
 
</div>
<div id="WebGL-output">
</div>

<!-- Javascript ThreeJs code -->
<script type="text/javascript">
    window.onload = init;
	
    function init() {
		//初始化通用变量
		var WIDTH = window.innerWidth;
		var HIGHT = window.innerHeight;
		var mouse = new THREE.Vector2();
		mouse.x = mouse.y = 0;
			
		var infoArea = document.getElementById("info-area");
		var modelList = ["main"];
								
		var raycaster = new THREE.Raycaster();
		var INTERSECTED;//上一帧选择的物体
			
			
		//建立场景，包括相机、渲染器
		createScene();
		//建立灯光
		createLights();
		//建立模型
		createModel(modelList);
		//建立控制器
		createControl();
		//建立辅助性对象
		createItem();
		//建立事件关联
		createListener();
		//渲染相机里场景
        render();

		var scene, camera, renderer;		
		function createScene(){
			scene = new THREE.Scene();
			camera = new THREE.PerspectiveCamera(60,  WIDTH/HIGHT , 0.1, 100000);
			camera.position.x = 100;
			camera.position.y = 66;
			camera.position.z = 500;
			camera.lookAt(scene.position);
			//camera.lookAt(0,0,-1);	  
			//camera.updateProjectionMatrix();
			
			renderer = new THREE.WebGLRenderer();
			renderer.setClearColor(0x999999, 1.0);
			renderer.setSize(window.innerWidth, window.innerHeight);

			renderer.shadowMap.enabled = true;
			document.getElementById("WebGL-output").appendChild(renderer.domElement);
			
	
		}
		
		var ambientLight, spotLight, light, lightHelper;
		function createLights(){
			ambientLight = new THREE.AmbientLight(0x888888);
			scene.add(ambientLight);		
			
			//var light = new THREE.DirectionalLight( 0xffffff, 0.2, 100 );
			//light.position.set( 0, 500, -500 );
			//light.target.position.set( 0, 0, 0 );
			//light.angle = Math.PI / 4;
			//light.castShadow = true;
			//light.receiveShadow = true;
			//light.shadow.mapSize.width = 10;
			//light.shadow.mapSize.height = 10;
			//light.shadow.camera.near = 10;
			//light.shadow.camera.far = 20;
			//scene.add( light );

			spotLight = new THREE.SpotLight(0xffffff,0.6);
			spotLight.position.set(0, 500, -500);
			spotLight.castShadow = true;
			scene.add(spotLight);
				
			//lightHelper = new THREE.SpotLightHelper( light );
			//scene.add( lightHelper );		
		}
	

		function createModel(modelList){
			var onProgress = function ( xhr ) {
				if ( xhr.lengthComputable ) {
					var percentComplete = xhr.loaded / xhr.total * 100;
					console.log( Math.round( percentComplete, 2 ) + '% downloaded' );
				}
			};
			var onError = function ( xhr ) { };
			
			for(var i = 0; i < modelList.length; i++){	
				var modelName = modelList[i];
				new THREE.MTLLoader()
					.setPath( './model/' ).load( modelName+".mtl", 
						function ( materials ) {
							materials.preload();
							new THREE.OBJLoader()
								.setMaterials( materials )
								.setPath( './model/' ).load( modelName+".obj", 
								function ( object ) {
									object.rotateY(180);
									object.traverse(function(o){
										o.receiveShadow = true;
										console.log(o.name);
									});						
									scene.add( object );
								}, onProgress, onError );
						},onProgress, onError );	
						
			}
				
			//TEMP test
			var cubeGeometry = new THREE.BoxGeometry(40, 40, 40);
			var cubeMaterial = new THREE.MeshPhongMaterial({color: 0xf58cff, wireframe: false});
			var test = new THREE.Mesh(cubeGeometry, cubeMaterial);
			test.position.x = 0;
			test.position.y = 0;
			test.position.z = 300;
			test.name = "testmodel";
			//scene.add( test );		
		
		}

		var clock, firstPersonControl, orbitControl;
		function createControl(){
			//相机控制
			clock = new THREE.Clock();
			firstPersonControl = new THREE.FirstPersonControls(camera);
			firstPersonControl.lookSpeed = 0.05; //鼠标移动查看的速度
			firstPersonControl.movementSpeed = 100; //相机移动速度
			firstPersonControl.lookVertical = true;
			firstPersonControl.noFly = true;
			firstPersonControl.constrainVertical = true; //约束垂直
			
			firstPersonControl.verticalMin = 1.0;
			firstPersonControl.verticalMax = 2.0;
			firstPersonControl.lon = -90; //进入初始视角x轴的角度
			firstPersonControl.lat = 0; //初始视角进入后y轴的角度		

			//orbitControl = new THREE.OrbitControls(camera,document.getElementById("WebGL-output"));
		}

		var stats, AxesHelper;
		function createItem(){
			AxesHelper = new THREE.AxesHelper(10000);
			//scene.add(AxesHelper);	
			
			stats = initStats();			


		}

		function createListener(){
			document.addEventListener( 'mousemove', onDocumentMouseMove, false );
		
		}



        function render() {
            stats.update();   
			//if(Math.abs(mouse.x) > 0.2 || Math.abs(mouse.y) > 0.2 ){
			firstPersonControl.update(clock.getDelta());			
			//}
			//摄影机高度维持在人眼的高度
			camera.position.y = 66;
			
			//相交判断
			intersect();
            requestAnimationFrame(render);
            renderer.render(scene, camera);
        }

        function initStats() {
            var stats = new Stats();
            stats.setMode(0); // 0: fps, 1: ms
            // Align top-left
            stats.domElement.style.position = 'absolute';
            stats.domElement.style.right = '0px';
            stats.domElement.style.top = '0px';
            document.getElementById("Stats-output").appendChild(stats.domElement);
            return stats;
        }

		function onDocumentMouseMove( event ) {
			event.preventDefault();
			mouse.x = ( event.clientX / window.innerWidth ) * 2 - 1;
			mouse.y = - ( event.clientY / window.innerHeight ) * 2 + 1;
			//mouse.x = ( event.clientX / WIDTH ) * 2 - 1;
			//mouse.y = - ( event.clientY / HIGHT ) * 2 + 1;

		}
		
		//光线投射		
		function intersect(){
			raycaster.setFromCamera( mouse, camera );

			var intersects = raycaster.intersectObjects( scene.children , true );
			//1 当前选择了一个物体
			if ( intersects.length > 0 ) {
				//1.1 如果选择的是一个新物体
				if ( INTERSECTED != intersects[ 0 ].object ) {
					//1.1.1 恢复上一物体的颜色
					if ( INTERSECTED ){							
						//>判断对象上是否有多材质
						if(INTERSECTED.material instanceof Array){
							//>>高亮拾取对象中的每一个材质
							for(var i= 0; i < INTERSECTED.material.length; i++){
								var mat = INTERSECTED.material[i];	
								mat.emissive.setHex("#000");	//不发光						
							}
						}
						else{		
							//>>恢复上一物体的颜色，一个材质			
							INTERSECTED.material.emissive.setHex("#000");
						}						
					}	
					//////////////////////////////////////////////////////////////////////////
					//1.1.2 取intersects变量的第一个元素作为拾取到的
					INTERSECTED = intersects[ 0 ].object;
					//>判断对象上是否有多材质
					if(INTERSECTED.material instanceof Array){
						//>>高亮拾取对象中的每一个材质
						for(var i= 0; i < INTERSECTED.material.length; i++){
							var mat = INTERSECTED.material[i];						
							INTERSECTED.currentHex = mat.emissive.getHex();
							mat.emissive.setHex( 0xff0000 );			
						}
					}
					else{
						//>>高亮拾取对象，一个材质
						INTERSECTED.currentHex = INTERSECTED.material.emissive.getHex();
						INTERSECTED.material.emissive.setHex( 0xff0000 );					
						//console.log(INTERSECTED.currentHex);
					}
					
					infoArea.innerHTML = INTERSECTED.name;
					//console.log("new item.");

				}
				//1.2 如果选择没有变，还是同一个物体 
				else{
					//console.log("no change.");
				}
			}
			//2 当前没有选中物体
			else {
				//2.1 如果上一帧选择了物体,恢复物体颜色	（同1.1.1）
				if ( INTERSECTED ){							
					//判断对象上是否有多材质
					if(INTERSECTED.material instanceof Array){
						//>>高亮拾取对象中的每一个材质
						for(var i= 0; i < INTERSECTED.material.length; i++){
							var mat = INTERSECTED.material[i];	
							mat.emissive.setHex("#000");							
						}
					}
					else{		
						//>>恢复上一物体的颜色，一个材质			
						INTERSECTED.material.emissive.setHex("#000");
					}
					
				}	
				//2.2 置空
				infoArea.innerHTML = "-";
				INTERSECTED = null;

			}
				
				
	
		
		}
    }


	
</script>
</body>
</html>